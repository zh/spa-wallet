{"version":3,"sources":["slpwallet/Utils.ts","App.tsx","logo.svg","CacheSet.ts","slpwallet/Network/BchdNetwork.ts","slpwallet/Storage/BrowserStorage.ts","slpwallet/index.ts","index.tsx","slpwallet/TxBuilder.ts","slpwallet/Wallet.ts"],"names":["Utils","hash","hashHex","Buffer","from","toString","txid","Uint8Array","match","map","byte","parseInt","reverse","index","isTxid","indexBuf","alloc","writeUInt32BE","hashToTxid","outpoint","slice","vout","voutBuf","readUInt32BE","sleep","ms","Promise","resolve","setTimeout","TxnErrorTypes","myTableStyle","border","publicBchdNodes","App","props","domWallet","DomWallet","mounted","copyToClipboard","event","preventDefault","navigator","clipboard","writeText","state","address","setState","showCopySuccess","validateAddOutput","bchaddr","isValidAddress","outputAddressValue","txnValidationErrors","delete","INVALID_OUTPUT_ADDRESS","selectedSlpTokenId","isSlpAddress","NON_SLP_ADDRESS","add","Big","outputAmountValue","INVALID_OUTPUT_AMOUNT","_","txn","currentTxn","lt","BELOW_DUST_LIMIT","unspentAmt","Array","Wallet","BchCoins","reduce","p","c","i","satoshis","Outputs","gt","LOW_BCH_INPUTS","tokenAmt","getTokenAmount","ZERO_SLP_OUTPUT","tokenId","slpCoins","SlpCoins","get","unspentSlpAmt","amount","slpChangeAmt","SlpChangeOutput","SlpOutputs","sub","LOW_SLP_INPUTS","changeDust","DUST_LIMIT","opReturnSize","length","unspentBchAmt","bchChangeAmt","BchChangeOutput","TOO_MANY_SLP_DECIMAL_PLACES","size","forceUpdate","updateOutputAddress","target","value","outputAddressValid","updateSelectedToken","TxBuilder","selectedIndex","TokenMetadata","updateNodeUri","nodeUri","includes","setNode","LoadInitialBalances","Subscribe","UpdateWalletUI","currentNodeUri","Storage","GetNode","updateOutputValue","outputAmountValid","clearTransaction","clear","sendTransaction","a","SignTransaction","PrivateKey","txnHex","fee","sendAmount","console","log","Confirm","explorerUri","SendTransaction","Alert","href","rel","download","message","setMaxAmount","GetBchBalance","toFixed","bal","GetSlpBalances","amt","addOutput","addr","toCashAddress","val","AddBchOutput","Address","toNumber","AddSlpOutput","importMnemonic","userValue","UpdateMnemonic","showPrivKey","showSlpAddressFormat","toggleAddrFormat","toSlpAddress","useMainnet","toTestnetAddress","toggleMnemonic","checkingBalance","showCoins","showTxnInputs","slpOutputs","Set","this","className","src","logo","alt","width","height","htmlFor","id","onChange","onClick","hidden","defaultValue","Mnemonic","Wif","XPub","style","div","b","getTokenName","getSlpAmountString","getTokenTypeString","keyToOutpointString","coins","placeholder","getTokenTicker","err","Inputs","input","outpointToKey","prevTxId","outputIndex","slpOut","SlpOutpointCache","output","script","isDataOut","toBuffer","slpOuts","toAddress","decimals","display","tm","hasType1","getType1","getDecimals","hasNft1Group","getNft1Group","hasNft1Child","Error","mul","has","nameBuf","getTokenTicker_asU8","getNft1Child","getTokenName_asU8","getTypeMetadataCase","TypeMetadataCase","TYPE1","NFT1_GROUP","NFT1_CHILD","Component","Symbol","iterator","CacheSet","maxSize","set","list","values","item","shift","push","filter","k","pop","BchdNetwork","url","networkUrl","subscriptions","blockInfo","blockData","blockHeight","callback","client","GrpcClient","submitTransaction","res","getHash_asU8","getTransaction","reversedHashOrder","tokenIds","getTokenMetadata","sinceBlock","getBlockchainInfo","getSlpIndex","getAddressTransactions","addresses","onTransactionNotification","createTxnStream","subscribeTransactions","includeMempoolAcceptance","includeBlockAcceptance","includeSerializedTxn","txnStream","on","error","data","getUnconfirmedTransaction","createBlockDataStream","subscribeBlocks","includeSerializedBlock","blockDataStream","createBlockInfoStream","blockInfoStream","getBlockInfo","getHeight","BrowserLocalStorage","localStorage","getItem","seed","removeItem","setItem","wif","node","block","app","storage","network","Ready","Network","process","REACT_APP_RPC_SERVER","undefined","window","SetUri","SetNode","global","require","ReactDOM","render","StrictMode","document","getElementById","SlpVersionType","wallet","Transaction","slpOpreturnMessage","_changeIndex","idx","outputs","inputs","o","slpAmt","_changeScript","removeOutput","Output","Script","addSlpInputs","addBchInputs","to","getKeys","pk","sign","serialize","inputAmount","outputAmount","change","checkInputs","feePerByte","feeRate","GetFeeRate","bchCoins","sort","coin","skipCoin","addInput","Input","PublicKeyHash","buildPublicKeyHashOut","empty","amounts","amts","n","mdm","getTokenType","TokenVersionType1","send","TokenVersionType1_NFT_Group","Group","TokenVersionType1_NFT_Child","Child","checkSlpInputs","slpInputAmt","slpOutputAmt","minus","gte","createMd","txidsSeen","addressPath","parent","Map","mnemonic","privateKey","bchTxi","bchTxo","slpTxi","slpTxo","tokenMetadata","updateParent","GetWif","bip39","bip32","child","derivePath","toWIF","GetSeed","SetSeed","_estimateSize","EstimateTxnSize","rate","forEach","isMine","GetAddressTransactions","indexTransactionIO","getConfirmedTransactionsList","getUnconfirmedTransactionsList","m","_transformWIF","fromWIF","SetWif","inputAmt","slpBals","outs","processNewTransaction","GetTransaction","txns","tx","getInputsList","inp","getAddress","op","getOutpoint","getIndex","hasSlpToken","_tokenId","getSlpToken","getTokenId_asU8","getAmount","getValue","e","getOutputsList","out","GetTokenMetadata","keys","getTokenMetadataList","neutered","toBase58","_bip39_or_wif","dat","_coins","coinMap"],"mappings":"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","file":"static/js/main.726bad09.chunk.js","sourcesContent":["\n\nexport class Utils {\n  // this prevents us from getting into trouble with the reverse() function\n  public static hashToTxid(hash: Uint8Array): string {\n    const hashHex = Buffer.from(hash).toString(\"hex\");\n    const txid = new Uint8Array(hashHex.match(/.{1,2}/g)!.map((byte) => parseInt(byte, 16))).reverse();\n    return Buffer.from(txid).toString(\"hex\");\n  }\n\n  public static outpointToKey(hash: Uint8Array, index: number, isTxid=false): string {\n    const indexBuf = Buffer.alloc(4);\n    indexBuf.writeUInt32BE(index);\n    if (!isTxid) {\n      return Utils.hashToTxid(hash) + indexBuf.toString(\"hex\");\n    }\n    return Buffer.from(hash).toString(\"hex\") + indexBuf.toString(\"hex\");\n  }\n\n  public static keyToOutpointString(outpoint: string): string {\n    const txid = outpoint.slice(0, 64);\n    const vout = outpoint.slice(64, 72);\n    const voutBuf = Buffer.from(vout, \"hex\");\n    return `${txid}:${voutBuf.readUInt32BE(0)}`;\n  }\n\n  public static sleep = (ms: number) => new Promise<void>(resolve => setTimeout(resolve, ms));\n}\n\nexport default Utils;\n","import React, { Component } from \"react\";\nimport { Confirm, Alert } from 'react-st-modal';\nimport \"./App.css\";\nimport logo from \"./logo.svg\";\nimport QRCode from \"qrcode.react\";\n\nimport bchaddr from \"bchaddrjs-slp\";\nimport { Big } from \"big.js\";\nimport { TokenMetadata } from \"grpc-bchrpc-web/pb/bchrpc_pb\";\n\nimport { Address } from \"bitcore-lib-cash\";\nimport { DUST_LIMIT, TxBuilder } from \"./slpwallet/TxBuilder\";\nimport { DomWallet } from \"./slpwallet\";\nimport Utils from \"./slpwallet/Utils\";\n\ninterface IProps {}\n\ninterface IState {\n  showPrivKey?: boolean;\n  showSlpAddressFormat?: boolean;\n  showCopySuccess?: boolean;\n  useMainnet?: boolean;\n  address?: string;\n  checkingBalance?: boolean;\n  showCoins?: boolean;\n  showTxnInputs?: boolean;\n  outputAddressValue?: string;\n  outputAddressValid?: boolean;\n  outputAmountValue?: string;\n  outputAmountValid?: boolean;\n  selectedSlpTokenId?: string;\n  slpOutputs?: Array<Big>;\n  slpChangeAmt?: Big;\n  currentTxn?: TxBuilder;\n  txnValidationErrors?: Set<string>;\n}\n\nenum TxnErrorTypes {\n  LOW_BCH_INPUTS = \"insufficient bch inputs\",\n  LOW_SLP_INPUTS = \"insufficient slp inputs\",\n  INVALID_OUTPUT_ADDRESS = \"invalid address\",\n  NON_SLP_ADDRESS = \"address isn't slp format\",\n  INVALID_OUTPUT_AMOUNT = \"invalid amount\",\n  BELOW_DUST_LIMIT = \"output is lower than dust limit\",\n  ZERO_SLP_OUTPUT = \"must have slp output > 0\",\n  TOO_MANY_SLP_DECIMAL_PLACES = \"too many decimal places for this slp token\"\n}\n\nconst myTableStyle = {\n  border:\"1px solid grey\",\n  \"marginLeft\": \"auto\",\n  \"marginRight\": \"auto\"\n} as React.CSSProperties;\n\nconst publicBchdNodes = [\n  'bchd.fountainhead.cash',\n  'bchd-mainnet.electroncash.de',\n  'bchd.imaginary.cash/proxy',\n  'bchd.greyh.at:8335',\n  'localhost:8335'\n]\n\nclass App extends Component<IProps, IState> {\n  private domWallet: DomWallet = new DomWallet(this);\n  private mounted = false;\n\n  constructor(props: IProps) {\n    super(props);\n\n    this.state = {\n      showPrivKey: false,\n      showSlpAddressFormat: true,\n      showCopySuccess: false,\n      address: bchaddr.toSlpAddress(this.domWallet.Wallet.Address.toCashAddress()),\n      useMainnet: true,\n      checkingBalance: true,\n      showCoins: false,\n      showTxnInputs: false,\n      outputAddressValue: \"\",\n      outputAddressValid: false,\n      outputAmountValue: \"\",\n      outputAmountValid: false,\n      selectedSlpTokenId: \"bch\",\n      slpOutputs: [],\n      currentTxn: new TxBuilder(this.domWallet.Wallet),\n      txnValidationErrors: new Set<string>()\n    };\n  }\n\n  public componentDidMount() {\n    this.mounted = true;\n    this.domWallet.Wallet.LoadInitialBalances();\n    this.domWallet.Wallet.Subscribe();\n  }\n\n  public UpdateWalletUI() {\n    if (this.mounted) {\n      this.forceUpdate();\n    }\n  }\n\n  public render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n            {/* Learn more about BCH! */}\n            <br/>\n            <a\n              className=\"App-link\"\n              href=\"https://bch.info\"\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              <img src={logo} className=\"App-logo\" alt=\"logo\" width=\"30%\" height=\"30%\"/>\n            </a>\n        </header>\n          {/* Switch bchd node */}\n          <p>\n            <label htmlFor=\"node\">Node: </label>\n            <select id=\"node\" value={this.currentNodeUri()} onChange={this.updateNodeUri}>\n              {publicBchdNodes.map((nodeUri) => (<option key={nodeUri} value={nodeUri}>{nodeUri}</option>))}\n            </select>\n          </p>\n          {/* Display private key backup! */}\n          <strong>Back up your funds with your seed or WIF!!!</strong><br/>\n          <button\n            onClick={this.toggleMnemonic}\n          >\n            {this.state.showPrivKey ? \"Hide\" : \"Show\"} Private Keys\n          </button>&nbsp;&nbsp;\n          <a\n            href=\"https://iancoleman.io/bip39/\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Generate Keys (BIP39)\n          </a><br/><br/>\n          <div hidden={!this.state.showPrivKey}>\n            WIF or seed: <input className=\"App-private-keys\" defaultValue={`${this.domWallet.Wallet.Mnemonic ? this.domWallet.Wallet.Mnemonic : this.domWallet.Wallet.Wif}`} onChange={this.importMnemonic}/><br/>\n            <div hidden={this.domWallet.Wallet.XPub === null}>\n              Xpub:<br/>{this.domWallet.Wallet.XPub}\n            </div>\n          </div>\n          <hr />\n\n          {/* Display address */}\n          <div>\n            <strong>Your wallet address:</strong><br/><br/>\n            <div onClick={this.copyToClipboard}>\n              <QRCode value={this.state.address!} /><br/><br/>\n              <div className=\"App-qr-text\">{this.state.address!}</div>\n              {this.state.showCopySuccess && <div className=\"App-qr-success\"> (copied!) </div>}\n            </div>\n            <br/>\n            <button\n            onClick={this.toggleAddrFormat}\n            >\n              Switch to {this.state.showSlpAddressFormat ? \"cash\" : \"slp\" }Addr format\n            </button>\n          </div>\n          <hr />\n\n          {/* Display SLP token balances */}\n          <div hidden={this.domWallet.Wallet.SlpCoins.size === 0}>\n            <strong>Balances:</strong><br/>\n            <table style={myTableStyle}>\n              <thead><tr><th>name</th><th>amount</th><th>type</th></tr></thead>\n              <tbody>\n                <tr key=\"bch-bal\"><td>BCH</td><td>{this.domWallet.Wallet.GetBchBalance().div(10**8).toFixed(8)}</td><td>&nbsp;</td></tr>\n              {\n                Array.from(this.domWallet.Wallet.GetSlpBalances()).map(b => {\n                  return (<tr key={`${b[0]}-bal`}><td>{this.getTokenName(b[0])}</td><td>{this.getSlpAmountString(b[1], b[0])}</td><td>{this.getTokenTypeString(b[0])}</td></tr>);\n                })\n              }\n              </tbody>\n            </table>\n          </div><br/>\n          <p hidden={this.domWallet.Wallet.SlpCoins!.size !== 0}>\n            No BCH or SLP balance.\n          </p>\n\n          {/* Coins */}\n          <div hidden={this.domWallet.Wallet.BchCoins.size === 0 && this.domWallet.Wallet.SlpCoins.size === 0}>\n            <button\n              onClick={() => this.setState({ showCoins: !this.state.showCoins })}\n            >\n              {this.state.showCoins ? \"Hide\" : \"Show\"} UTXOs List\n            </button>\n          </div>\n          <div hidden={!this.state.showCoins}>\n            <table style={myTableStyle}>\n              <thead><tr><th>UTXO</th><th>Amount</th><th>Name</th><th>Type</th></tr></thead>\n              <tbody>\n                {Array.from(this.domWallet.Wallet.BchCoins).map(c => {\n                  return (<tr key={c[0]}><td>{Utils.keyToOutpointString(c[0])}</td><td>{c[1].satoshis.div(10**8).toFixed(8)}</td><td>BCH</td></tr>);\n                })}\n                {Array.from(this.domWallet.Wallet.SlpCoins).map(([tokenId, coins]) => {\n                  return Array.from(coins).map(c => {\n                    return (<tr key={c[0]}><td>{Utils.keyToOutpointString(c[0])}</td><td>{this.getSlpAmountString(c[1].amount, tokenId)}</td><td>{this.getTokenName(tokenId)}</td><td>{this.getTokenTypeString(tokenId)}</td></tr>);\n                  })\n                })}\n              </tbody>\n            </table>\n          </div>\n          <hr />\n\n          {/* Create a Transaction */}\n          <strong>Send</strong><br/>\n          <label htmlFor=\"payto\">PayTo: </label>\n          <input className=\"App-pay-to\" id=\"payto\" value={this.state.outputAddressValue} placeholder={this.state.selectedSlpTokenId! === \"bch\" ? \"cash or slp address\" : \"slp address\"} onChange={this.updateOutputAddress}></input><br/>\n          <label htmlFor=\"coin\">Coin: </label>\n          <select id=\"coin\" value={this.state.selectedSlpTokenId} onChange={this.updateSelectedToken}>\n            {Array.from(this.domWallet.Wallet.SlpCoins).map(([tokenId, _]) => (<option key={tokenId} value={tokenId}>{`SLP -> ${this.getTokenName(tokenId)} (${this.getTokenTypeString(tokenId)})`}</option>))}\n            <option key=\"bch\" value=\"bch\">Bitcoin Cash</option>\n          </select>&nbsp;&nbsp;\n          <label htmlFor=\"amount\">Amount: </label>\n          <input className=\"App-amount\" id=\"amount\" value={this.state.outputAmountValue} placeholder={this.getTokenTicker()} onChange={this.updateOutputValue}></input>&nbsp;&nbsp;\n          <button onClick={this.setMaxAmount}>Max</button><br/><br/>\n          <button onClick={this.addOutput}>Add Output</button><br/>\n          <div hidden={this.state.txnValidationErrors!.size === 0}>\n            <br/><strong>Validation Errors</strong>\n            <table style={myTableStyle}>\n              <tbody>\n                {Array.from(this.state.txnValidationErrors!).map((err, i) => {\n                    return (<tr key={i}><td>{err}</td></tr>);\n                })}\n              </tbody>\n            </table>\n          </div><br/>\n\n          {/* Show Txn Inputs */}\n          <div hidden={this.state.currentTxn!.Inputs.length === 0}>\n            <div hidden={!this.state.showTxnInputs!}>\n              Txn Inputs\n              <table style={myTableStyle}>\n                <tbody>\n                  {Array.from(this.state.currentTxn!.Inputs).map((input, i) => {\n                    let outpoint = Utils.outpointToKey(input.prevTxId, input.outputIndex, true);\n                    let slpOut = this.domWallet.Wallet.SlpOutpointCache.get(outpoint)!;\n                    if (slpOut) {\n                      return (<tr key={i}><td>{`${input.prevTxId.toString(\"hex\")}:${input.outputIndex}, ${this.getSlpAmountString(slpOut.amount, slpOut.tokenId)} ${this.getTokenTicker(slpOut.tokenId)}, ${slpOut.satoshis} sats`}</td></tr>);\n                    }\n                    return (<tr key={i}><td>{`${input.prevTxId.toString(\"hex\")}:${input.outputIndex}, ${input.output!.satoshis} sats`}</td></tr>);\n                  })}\n                </tbody>\n              </table>\n            </div>\n            <button\n              onClick={() => this.setState({ showTxnInputs: !this.state.showTxnInputs })}\n            >\n              {this.state.showTxnInputs! ? \"Hide\" : \"Show\"} Transaction Inputs\n            </button>\n          </div><br/>\n\n          {/* Show Txn Outputs */}\n          <div hidden={this.state.currentTxn!.Outputs.length === 0}>\n            <strong>Txn Outputs</strong>\n            <table style={myTableStyle}>\n              <tbody>\n                  {Array.from(this.state.currentTxn!.Outputs).map((output, i) => {\n                    if (output[0].script.isDataOut()) {\n                      return (<tr key={i}><td>{`SLP Metadata message, ${output[0].script.toBuffer().length} bytes, ${output[0].satoshis} sats`}</td></tr>);\n                    }\n                    let slpOuts = this.state.currentTxn!.SlpOutputs;\n                    if (slpOuts.length > 0 && i <= slpOuts.length) {\n                      return (<tr key={i}><td>{`${output[0].script.toAddress().toCashAddress()}, ${this.getSlpAmountString(slpOuts[i-1])} ${this.getTokenTicker()}, ${output[0].satoshis} sats`}</td></tr>);\n                    }\n                    return (<tr key={i}><td>{`${output[0].script.toAddress().toCashAddress()}, ${output[0].satoshis} sats`}</td></tr>);\n                  })}\n              </tbody>\n            </table><br/>\n          </div>\n\n          <div hidden={this.state.currentTxn!.Outputs.length === 0 || this.state.txnValidationErrors!.size !== 0}>\n            <button onClick={this.sendTransaction}>Send</button>&nbsp;&nbsp;\n            <button onClick={this.clearTransaction}>Clear</button>\n          </div>\n\n          <footer className=\"App-footer\">\n             Based on <a href=\"https://github.com/jcramer/bitcore-lib-fun\"\n                  target=\"_blank\"\n                  rel=\"noopener noreferrer\">bitcore-lib-fun</a>.&nbsp;&nbsp;\n             Sources on <a href=\"https://github.com/zh/spa-wallet\"\n                  target=\"_blank\"\n                  rel=\"noopener noreferrer\">Github</a>.\n          </footer>\n        </div>\n    );\n  }\n\n  public setState(state: IState) {\n    return new Promise((resolve: any) => {\n      super.setState(state, resolve);\n    });\n  }\n\n  public copyToClipboard = (event: React.MouseEvent<HTMLDivElement>) => {\n    event.preventDefault();\n    navigator.clipboard.writeText(this.state.address!);\n    this.setState({ showCopySuccess: true });\n  };\n\n  private validateAddOutput = (): number => {\n\n    // address input box\n    if (bchaddr.isValidAddress(this.state.outputAddressValue!)) {\n      this.state.txnValidationErrors!.delete(TxnErrorTypes.INVALID_OUTPUT_ADDRESS);\n      if (this.state.selectedSlpTokenId !== \"bch\" && !bchaddr.isSlpAddress(this.state.outputAddressValue!)) {\n        this.state.txnValidationErrors!.add(TxnErrorTypes.NON_SLP_ADDRESS);\n      } else if (this.state.selectedSlpTokenId !== \"bch\") {\n        this.state.txnValidationErrors!.delete(TxnErrorTypes.NON_SLP_ADDRESS);\n      }\n    } else {\n      this.state.txnValidationErrors!.add(TxnErrorTypes.INVALID_OUTPUT_ADDRESS);\n      this.state.txnValidationErrors!.delete(TxnErrorTypes.NON_SLP_ADDRESS);\n    }\n\n    // amount input box\n    try {\n      Big(this.state.outputAmountValue!);\n      this.state.txnValidationErrors!.delete(TxnErrorTypes.INVALID_OUTPUT_AMOUNT);\n    } catch (_) {\n      this.state.txnValidationErrors!.add(TxnErrorTypes.INVALID_OUTPUT_AMOUNT);\n    }\n\n    const txn = this.state.currentTxn!;\n    if (this.state.selectedSlpTokenId === \"bch\") {\n      if (this.state.outputAmountValue && Big(this.state.outputAmountValue!).lt(546)) {\n        this.state.txnValidationErrors!.add(TxnErrorTypes.BELOW_DUST_LIMIT);\n      } else {\n        this.state.txnValidationErrors!.delete(TxnErrorTypes.BELOW_DUST_LIMIT);\n      }\n\n      if (this.state.outputAmountValue) {\n        const unspentAmt = Array.from(this.domWallet.Wallet.BchCoins).reduce((p, c, i) => p.add(c[1].satoshis), Big(0))\n        const outputAmt = txn.Outputs.reduce((p, c, i) => p.add(c[0].satoshis), Big(0)).add(this.state.outputAmountValue!);\n        if (outputAmt.gt(unspentAmt)) {\n          this.state.txnValidationErrors!.add(TxnErrorTypes.LOW_BCH_INPUTS);\n        } else {\n          this.state.txnValidationErrors!.delete(TxnErrorTypes.LOW_BCH_INPUTS);\n        }\n      } else {\n        this.state.txnValidationErrors!.delete(TxnErrorTypes.LOW_BCH_INPUTS);\n      }\n\n    } else {\n      this.state.txnValidationErrors!.delete(TxnErrorTypes.BELOW_DUST_LIMIT);\n      this.state.txnValidationErrors!.delete(TxnErrorTypes.LOW_BCH_INPUTS);\n\n      // check slp balance\n      if (this.state.outputAmountValue!) {\n\n        const tokenAmt = this.getTokenAmount(new Big(this.state.outputAmountValue!), this.state.selectedSlpTokenId!);\n\n        if (this.state.outputAmountValue && tokenAmt.lt(1)) {\n          this.state.txnValidationErrors!.add(TxnErrorTypes.ZERO_SLP_OUTPUT);\n        } else {\n          this.state.txnValidationErrors!.delete(TxnErrorTypes.ZERO_SLP_OUTPUT);\n        }\n\n        const tokenId = this.state.selectedSlpTokenId!;\n        const slpCoins = this.domWallet.Wallet.SlpCoins.get(tokenId)!;\n        const unspentSlpAmt = Array.from(slpCoins).reduce((p, c, i) => p.add(c[1].amount), Big(0));\n        const slpChangeAmt = this.state.currentTxn!.SlpChangeOutput ? this.state.currentTxn!.SlpChangeOutput.amount : 0;\n        const outputAmt = txn.SlpOutputs.reduce((p, c, i) => p.add(c), Big(0)).add(tokenAmt).sub(slpChangeAmt);\n        if (outputAmt.gt(unspentSlpAmt)) {\n          this.state.txnValidationErrors!.add(TxnErrorTypes.LOW_SLP_INPUTS);\n        } else {\n          this.state.txnValidationErrors!.delete(TxnErrorTypes.LOW_SLP_INPUTS);\n        }\n\n        // TODO: actually check if slp change output will be needed\n        const changeDust = this.state.currentTxn!.SlpChangeOutput ? DUST_LIMIT : 0;\n        const opReturnSize = 10 + 32 + 9 * txn.SlpOutputs.length;\n\n        // check for sufficient bch balance when new slp output (bch dust) is added\n        const unspentBchAmt = Array.from(this.domWallet.Wallet.BchCoins).reduce((p, c, i) => p.add(c[1].satoshis), Big(0));\n        const bchChangeAmt = txn.BchChangeOutput ? txn.BchChangeOutput.amount : 0;\n        const outputBchAmt = txn.Outputs.reduce((p, c, i) => p.add(c[0].satoshis), Big(0)).add(DUST_LIMIT).add(changeDust).add(opReturnSize).sub(bchChangeAmt);\n        if (outputBchAmt.gt(unspentBchAmt)) {\n          this.state.txnValidationErrors!.add(TxnErrorTypes.LOW_BCH_INPUTS);\n        } else {\n          this.state.txnValidationErrors!.delete(TxnErrorTypes.LOW_BCH_INPUTS);\n        }\n\n        // check input amount decimal places doesn't exceed\n        if (tokenAmt.lt(1)) {\n          this.state.txnValidationErrors!.add(TxnErrorTypes.TOO_MANY_SLP_DECIMAL_PLACES);\n        } else {\n          this.state.txnValidationErrors!.delete(TxnErrorTypes.TOO_MANY_SLP_DECIMAL_PLACES);\n        }\n      } else {\n        this.state.txnValidationErrors!.delete(TxnErrorTypes.LOW_SLP_INPUTS);\n        this.state.txnValidationErrors!.delete(TxnErrorTypes.LOW_BCH_INPUTS);\n        this.state.txnValidationErrors!.delete(TxnErrorTypes.ZERO_SLP_OUTPUT);\n        this.state.txnValidationErrors!.delete(TxnErrorTypes.TOO_MANY_SLP_DECIMAL_PLACES);\n      }\n    }\n\n    if (this.state.txnValidationErrors!.size > 0) {\n      this.forceUpdate();\n    }\n\n    return this.state.txnValidationErrors!.size;\n  }\n\n  private updateOutputAddress = (event: React.ChangeEvent<HTMLInputElement>) => {\n    if (bchaddr.isValidAddress(event.target.value)) {\n      this.setState({ outputAddressValid: true, outputAddressValue: event.target.value });\n      return;\n    }\n    this.setState({ outputAddressValid: false, outputAddressValue: event.target.value });\n  }\n\n  private updateSelectedToken = (event: React.ChangeEvent<HTMLSelectElement>) => {\n    let tokenId = event.target.value;\n    if (tokenId !== this.state.selectedSlpTokenId) {\n      this.setState({ currentTxn: new TxBuilder(this.domWallet.Wallet)})\n    }\n    if (event.target.selectedIndex < this.domWallet.Wallet.TokenMetadata.size) {\n      this.setState({ selectedSlpTokenId: tokenId });\n    } else {\n      this.setState({ selectedSlpTokenId: \"bch\" });\n    }\n  }\n\n  private updateNodeUri = (event: React.ChangeEvent<HTMLSelectElement>) => {\n    let nodeUri = event.target.value;\n    if (publicBchdNodes.includes(nodeUri)) {\n      this.domWallet.setNode(nodeUri);\n      this.domWallet.Wallet.LoadInitialBalances();\n      this.domWallet.Wallet.Subscribe();\n      this.UpdateWalletUI();\n    }\n  }\n\n  private currentNodeUri = (): string => {\n    return this.domWallet.Storage.GetNode() || publicBchdNodes[0];\n  }\n\n  private updateOutputValue = (event: React.ChangeEvent<HTMLInputElement>) => {\n    try {\n      Big(event.target.value);\n    } catch (_) {\n      this.setState({ outputAmountValid: false, outputAmountValue: event.target.value });\n      return;\n    }\n\n    // check\n    if (Big(event.target.value).lt(546)) {\n      this.setState({ outputAmountValid: false, outputAmountValue: event.target.value });\n      return;\n    }\n\n    this.setState({ outputAmountValid: true, outputAmountValue: event.target.value });\n  }\n\n  private clearTransaction = () => {\n    this.state.txnValidationErrors!.clear();\n    this.setState({\n      outputAddressValue: \"\",\n      outputAmountValue: \"\",\n      currentTxn: new TxBuilder(this.domWallet.Wallet),\n      selectedSlpTokenId: \"bch\",\n    });\n  }\n\n  private sendTransaction = async () => {\n    try {\n      const { txnHex, fee, sendAmount } = await this.state.currentTxn!.SignTransaction(() => this.domWallet.Wallet.PrivateKey);\n      console.log(txnHex);\n      const ok = await Confirm(`${sendAmount} satoshis with fee: ${fee} satoshis?`, 'Sending transaction');\n      if (ok) {\n        const explorerUri = 'https://explorer.bitcoin.com/bch/tx/'\n        const txid = await this.domWallet.Wallet.SendTransaction(txnHex);\n        await Alert(<a href={`${explorerUri}${txid}`} target=\"_blank\" rel=\"noopener noreferrer\" download>{txid}</a>, 'Broadcasted');\n        this.clearTransaction();\n        this.forceUpdate();\n      }\n    } catch (err) {\n      // TODO: parse various error responses for better UI\n      await Alert(`Error: ${err.message}`);\n    }\n  }\n\n  private setMaxAmount = () => {\n    if (this.state.selectedSlpTokenId === \"bch\") {\n      this.setState({ outputAmountValue: this.domWallet.Wallet.GetBchBalance().toFixed() })\n    } else {\n      let bal = this.domWallet.Wallet.GetSlpBalances().get(this.state.selectedSlpTokenId!)!;\n      let amt = this.getTokenAmount(bal, this.state.selectedSlpTokenId!, true);\n      this.setState({ outputAmountValue: amt.toFixed() });\n    }\n  };\n\n  private addOutput = () => {\n    if (this.validateAddOutput() > 0) {\n      return;\n    }\n\n    // get address and value\n    const addr = bchaddr.toCashAddress(this.state.outputAddressValue!);\n    const val = Big(this.state.outputAmountValue!);\n\n    // Add bch or slp output\n    switch (this.state.selectedSlpTokenId) {\n      case \"bch\":\n        if (!this.state.currentTxn!.AddBchOutput(new Address(addr), val.toNumber())) {\n          this.state.txnValidationErrors!.add(TxnErrorTypes.LOW_BCH_INPUTS);\n        } else {\n          this.state.txnValidationErrors!.delete(TxnErrorTypes.LOW_BCH_INPUTS);\n        }\n        break;\n      default:\n        const tokenAmt = this.getTokenAmount(val, this.state.selectedSlpTokenId!);\n        this.state.currentTxn!.AddSlpOutput(addr, tokenAmt, this.state.selectedSlpTokenId!);\n        break;\n    }\n\n    this.forceUpdate();\n  }\n\n  private getTokenAmount(val: Big, tokenId: string, display=false) {\n    const tm = this.domWallet.Wallet.TokenMetadata.get(tokenId)!;\n    let decimals: number;\n    if (tm.hasType1()) {\n      decimals = tm.getType1()!.getDecimals();\n    } else if (tm.hasNft1Group()) {\n      decimals = tm.getNft1Group()!.getDecimals();\n    } else if (tm.hasNft1Child()) {\n      decimals = 0;\n    } else {\n      throw Error(\"unknown token type\");\n    }\n    if (display) {\n      return val.div(10**decimals);\n    }\n    return val.mul(10**decimals);\n  }\n\n  private importMnemonic = (event: React.ChangeEvent<HTMLInputElement>) => {\n    const userValue = event.target.value!;\n    if (!userValue) {\n      return;\n    }\n    this.setState({ showCopySuccess: false });\n    try {\n      this.domWallet.Wallet.UpdateMnemonic(userValue);\n    } catch (_) {\n      console.log(`invalid wif: ${userValue}`);\n    }\n    this.setState({\n      address: this.domWallet.Wallet.Address.toCashAddress(),\n      showPrivKey: false,\n      showSlpAddressFormat: false,\n      // loading: true // TODO: provide UI indication that the wallet balances are loading.\n    });\n\n    this.domWallet.Wallet.LoadInitialBalances();\n  }\n\n  private getTokenTicker(tokenId?: string): string {\n    if (!tokenId) {\n      tokenId = this.state.selectedSlpTokenId!;\n    }\n    if (tokenId === \"bch\") {\n      return \"satoshis\";\n    }\n    if (!this.domWallet.Wallet.TokenMetadata!.has(tokenId)) {\n      return `?`;\n    }\n    const tm = this.domWallet.Wallet.TokenMetadata!.get(tokenId)!;\n    let nameBuf: Uint8Array;\n    if (tm.hasType1()) {\n      nameBuf = tm.getType1()!.getTokenTicker_asU8();\n    } else if (tm.hasNft1Group()) {\n      nameBuf = tm.getNft1Group()!.getTokenTicker_asU8();\n    } else if (tm.hasNft1Child()) {\n      nameBuf = tm.getNft1Child()!.getTokenTicker_asU8();\n    } else {\n      throw Error(\"unknown token type\");\n    }\n    return Buffer.from(nameBuf).toString(\"utf8\");\n  }\n\n  private getTokenName(tokenId: string): string {\n    if (tokenId === \"bch\") {\n      return \"Bitcoin Cash\"\n    }\n    if (!this.domWallet.Wallet.TokenMetadata!.has(tokenId)) {\n      return `${tokenId.slice(0, 10)}...${tokenId.slice(54, 64)}`;\n    }\n    const tm = this.domWallet.Wallet.TokenMetadata!.get(tokenId)!;\n    let nameBuf: Uint8Array;\n    if (tm.hasType1()) {\n      nameBuf = tm.getType1()!.getTokenName_asU8();\n    } else if (tm.hasNft1Group()) {\n      nameBuf = tm.getNft1Group()!.getTokenName_asU8();\n    } else if (tm.hasNft1Child()) {\n      nameBuf = tm.getNft1Child()!.getTokenName_asU8();\n    } else {\n      throw Error(\"unknown token type\");\n    }\n    return Buffer.from(nameBuf).toString(\"utf8\");\n  }\n\n  private getTokenTypeString(tokenId: string): string {\n    const tm = this.domWallet.Wallet.TokenMetadata.get(tokenId);\n    if (!tm) {\n      return \"?\";\n    }\n    switch (tm.getTypeMetadataCase()) {\n      case TokenMetadata.TypeMetadataCase.TYPE1:\n        return \"Token\";\n      case TokenMetadata.TypeMetadataCase.NFT1_GROUP:\n        return \"NFT Group\";\n      case TokenMetadata.TypeMetadataCase.NFT1_CHILD:\n        return \"NFT\";\n      default:\n        return \"?\";\n    }\n  }\n\n  private getSlpAmountString(amount: Big, tokenId?: string): string {\n    if (!tokenId) {\n      tokenId = this.state.selectedSlpTokenId!;\n    }\n    const tm = this.domWallet.Wallet.TokenMetadata!.get(tokenId)!;\n    // if (!tm) {\n    //   return \"...\";\n    // }\n    let decimals: number;\n    if (tm.hasType1()) {\n      decimals = tm.getType1()!.getDecimals();\n    } else if (tm.hasNft1Group()) {\n      decimals = tm.getNft1Group()!.getDecimals();\n    } else if (tm.hasNft1Child()) {\n      decimals = 0;\n    } else {\n      throw Error(\"unknown token type\");\n    }\n    return amount.div(10 ** decimals).toFixed();\n  }\n\n  private toggleAddrFormat = async () => {\n    this.setState({ showCopySuccess: false });\n    let address = this.domWallet.Wallet.Address.toCashAddress();\n    if (!this.state.showSlpAddressFormat) {\n      address = bchaddr.toSlpAddress(address);\n    }\n    if (!this.state.useMainnet) {\n      address = bchaddr.toTestnetAddress(address);\n    }\n    await this.setState({\n      showSlpAddressFormat: !this.state.showSlpAddressFormat,\n      address,\n    });\n  }\n\n  private toggleMnemonic = () => {\n    this.setState({\n      showPrivKey: !this.state.showPrivKey\n    });\n  }\n\n}\n\nexport default App;\n","export default __webpack_public_path__ + \"static/media/logo.a5dd61ec.svg\";","export class CacheSet<T> {\n  private set = new Set<T>();\n  private list: T[] = [];\n  private maxSize: number;\n\n  constructor(maxSize: number) {\n    this.maxSize = maxSize;\n  }\n\n  public [Symbol.iterator]() {\n    return this.list.values();\n  }\n\n  get length(): number {\n    return this.list.length;\n  }\n\n  public push(item: T) {\n    this.set.add(item);\n    if (this.maxSize > 0 && this.set.size > this.maxSize) {\n    this.shift();\n    }\n    return this.list.push(item);\n  }\n\n  public has(item: T) {\n    return this.set.has(item);\n  }\n\n  public delete(item: T) {\n    if (this.set.delete(item)) {\n      this.list = this.list.filter(k => k !== item);\n    }\n  }\n\n  public toSet() {\n    return this.set;\n  }\n\n  public shift(): T | undefined {\n    const item = this.list.shift();\n    if (item) {\n      this.set.delete(item);\n    }\n    return item;\n  }\n\n  public pop(): T | undefined {\n    const item = this.list.pop();\n    if (item) {\n      this.set.delete(item);\n    }\n    return item;\n  }\n\n  public clear() {\n    this.list = [];\n    this.set.clear();\n  }\n}\n  ","import { BlockNotification, GetAddressTransactionsResponse, GetTokenMetadataResponse,\n  GetTransactionResponse, GrpcClient, Transaction, TransactionNotification } from \"grpc-bchrpc-web\";\nimport Utils from \"../Utils\";\n\nexport interface Network {\n  SendTransaction(txnHex: string, callback?: () => any): Promise<string>;\n  GetTransaction(txid: string): Promise<GetTransactionResponse>;\n  GetTokenMetadata(tokenIds: string[]): Promise<GetTokenMetadataResponse>;\n  GetAddressTransactions(address: string, sinceBlock?: number): Promise<GetAddressTransactionsResponse>;\n  Subscribe(addresses: string[], onTransactionNotification: (txn: Transaction) => any): Promise<void>;\n}\n\nexport class BchdNetwork implements Network {\n\n  private networkUrl: string;\n  private subscriptions = { txn: false, blockInfo: false, blockData: false };\n  private blockHeight = -1;\n\n  constructor(url: string) {\n    this.networkUrl = url;\n  }\n\n  public SetUri(url: string) {\n    this.networkUrl = url;\n  }\n\n  public async SendTransaction(txnHex: string, callback?: () => any): Promise<string> {\n    const client = new GrpcClient({ url: this.networkUrl });\n    let res = await client.submitTransaction({txnHex});\n    if (callback) {\n      callback();\n    }\n    return Buffer.from(res.getHash_asU8().reverse()).toString(\"hex\");\n  }\n\n  public async GetTransaction(txid: string) {\n    const client = new GrpcClient({ url: this.networkUrl });\n    return await client.getTransaction({hash: txid, reversedHashOrder: true}); \n  }\n\n  public async GetTokenMetadata(tokenIds: string[]) {\n    const client = new GrpcClient({url: this.networkUrl});\n    return await client.getTokenMetadata(tokenIds);\n  }\n\n  public async GetAddressTransactions(address: string, sinceBlock?: number) {\n    const client = new GrpcClient({ url: this.networkUrl });\n    const slpEnabled = (await client.getBlockchainInfo()).getSlpIndex();\n    if (! slpEnabled) {\n      throw Error(\"connected bchd does not have slp index enabled\");\n    }\n\n    return await client.getAddressTransactions({ address });\n  }\n\n  public async Subscribe(addresses: string[], onTransactionNotification: (txn: Transaction) => any) {\n\n    // setup a self-healing stream for mempool transactions\n    const createTxnStream = async () => {\n      if (this.subscriptions.txn) {\n        console.log(\"Txn stream already connected\");\n        return;\n      }\n      const client = new GrpcClient({ url: this.networkUrl });\n      const txnStream = await client.subscribeTransactions({\n        includeMempoolAcceptance: true,\n        includeBlockAcceptance: false,\n        includeSerializedTxn: false,\n        addresses: addresses\n      });\n\n      txnStream.on(\"end\", async (error) => {\n        this.subscriptions.txn = false;\n        while (true) {\n          await Utils.sleep(500);\n          try {\n            console.log(`[WALLET] trying to re-establish txn data stream...`);\n            await createTxnStream();\n            break;\n          } catch (error) {\n            console.log(error);\n          }\n        }\n      });\n\n      txnStream.on(\"data\", async (data: TransactionNotification) => {\n        this.subscriptions.txn = true;\n        let txn = data.getUnconfirmedTransaction()!.getTransaction()!;\n        onTransactionNotification(txn);\n      });\n      console.log(`[WALLET] txn data stream established.`);\n\n    };\n    await createTxnStream();\n\n    // setup a self-healing stream for getting serialized block data\n    const createBlockDataStream = async () => {\n      if (this.subscriptions.blockData) {\n        console.log(\"Txn stream already connected\");\n        return;\n      }\n      const client = new GrpcClient({ url: this.networkUrl });\n      const blockDataStream = await client.subscribeBlocks({ includeSerializedBlock: true });\n      blockDataStream.on(\"end\", async (error) => {\n        this.subscriptions.blockData = false;\n        while (true) {\n          await Utils.sleep(500);\n          try {\n            console.log(`[WALLET] trying to re-establish block data stream...`);\n            await createBlockDataStream();\n            break;\n          } catch (_) {}\n        }\n      });\n      blockDataStream.on(\"data\", async (data: BlockNotification) => {\n        this.subscriptions.blockData = true;\n        // const blockBuf = Buffer.from(data.getSerializedBlock_asU8());\n        // const block = new Block(blockBuf);\n        console.log(\"BLOCK found\");\n        // for (const txn of block.transactions) {\n        //   // todo...\n          \n        // }\n      });\n      console.log(`[WALLET] block data stream established.`);\n    };\n    await createBlockDataStream();\n\n    // setup a self-healing stream for getting block height\n    const createBlockInfoStream = async () => {\n      if (this.subscriptions.blockInfo) {\n        console.log(\"Txn stream already connected\");\n        return;\n      }\n      const client = new GrpcClient({ url: this.networkUrl });\n      const blockInfoStream = await client.subscribeBlocks();\n      blockInfoStream.on(\"end\", async (error) => {\n        this.subscriptions.blockInfo = false;\n        while (true) {\n          await Utils.sleep(500);\n          try {\n            console.log(`[WALLET] trying to re-establish block info stream...`);\n            await createBlockInfoStream();\n            break;\n          } catch (_) {}\n        }\n      });\n      blockInfoStream.on(\"data\", async (data: BlockNotification) => {\n        this.subscriptions.blockInfo = true;\n        const height = data.getBlockInfo()!.getHeight();\n        this.blockHeight = height;\n        console.log(`Block found: ${height}`);\n      });\n      console.log(`[WALLET] block info stream established.`);\n    };\n    await createBlockInfoStream();\n  }\n}\n","import { WalletStorage } from \"../Interfaces\";\n\nexport class BrowserLocalStorage implements WalletStorage {\n  public GetSeed() {\n    return localStorage.getItem(\"bitcore-fun-seed\");\n  }\n  public SetSeed(seed: string) {\n    localStorage.removeItem(\"bitcore-fun-wif\");\n    return localStorage.setItem(\"bitcore-fun-seed\", seed);\n  }\n  public GetWif() {\n    return localStorage.getItem(\"bitcore-fun-wif\");\n  }\n  public SetWif(wif: string) {\n    localStorage.removeItem(\"bitcore-fun-seed\");\n    return localStorage.setItem(\"bitcore-fun-wif\", wif);\n  }\n  public GetNode() {\n    return localStorage.getItem(\"bitcore-fun-node\");\n  }\n  public SetNode(node: string) {\n    localStorage.removeItem(\"bitcore-fun-node\");\n    return localStorage.setItem(\"bitcore-fun-node\", node);\n  }\n  public GetBlock(address: string): number|null {\n    let block = localStorage.getItem(address);\n    if (block) {\n      return parseInt(block, 10);\n    }\n    return null;\n  }\n  public SetBlock(address: string, height: number|null) {\n    if (!height) {\n      localStorage.removeItem(address);\n    }\n    return localStorage.setItem(address, height!.toString());\n  }\n}\n","import { App, WalletStorage } from \"./Interfaces\";\nimport { Wallet } from \"./Wallet\";\nimport { BrowserLocalStorage } from \"./Storage/BrowserStorage\";\nimport { BchdNetwork } from \"./Network/BchdNetwork\";\n\nconst DEFAULT_RPC_NODE = 'https://bchd.fountainhead.cash';\n\n// DomWallet is the most simple wallet implementation intended for prototyping purposes\n// by default using the browser's local storage for storing private keys.\nexport class DomWallet {\n    public Ready = false;\n    public Network = new BchdNetwork(process.env.REACT_APP_RPC_SERVER || DEFAULT_RPC_NODE);\n    public Wallet: Wallet;\n    public Storage = new BrowserLocalStorage();\n\n    constructor(app: App, storage?: WalletStorage, network?: BchdNetwork) {\n        if (window === undefined) {\n            throw Error(\"access to 'window' is not available.\");\n        }\n        if (storage) {\n            this.Storage = storage;\n        }\n        if (network) {\n            this.Network = network;\n        }\n        this.Wallet = new Wallet(this.Storage, this.Network, app);\n    }\n\n    public setNode(node: string) {\n        this.Network.SetUri(`https://${node}`);\n        this.Storage.SetNode(node);\n    }\n};\n","/* eslint-disable import/first */\nglobal.Buffer = require(\"buffer/\").Buffer;\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n","import Big from \"big.js\";\nimport { Address, PrivateKey, Script, Transaction } from \"bitcore-lib-cash\";\nimport * as mdm from \"slp-mdm\";\nimport { Wallet } from \"./Wallet\";\nimport { TokenId } from \"./Interfaces\";\nimport Utils from \"./Utils\";\n\nexport const DUST_LIMIT = 546; // sats\nconst FEE_RATE = 1;            // sats/byte\n\nexport enum SlpVersionType {\n  \"TokenVersionType1\" = 1,\n  \"TokenVersionType1_NFT_Child\" = 65,\n  \"TokenVersionType1_NFT_Group\" = 129\n}\n\nexport class TxBuilder {\n  private wallet: Wallet;\n  private txn = new Transaction();\n  private tokenId = \"bch\";\n  private slpOpreturnMessage?: Buffer;\n  private slpChangeAmt?: { amount: Big, index: number };\n  private slpOutputs = new Array<Big>();\n\n  public get TokenId(): string {\n    return this.tokenId;\n  }\n\n  public get SlpOutputs(): Array<Big> {\n    if (this.slpChangeAmt) {\n      return [...this.slpOutputs, this.slpChangeAmt!.amount];\n    };\n    return [...this.slpOutputs];\n  }\n\n  public get SlpChangeOutput(): { amount: Big, index: number } | null {\n    if (!this.slpChangeAmt) {\n      return null;\n    }\n    return { amount: this.slpChangeAmt.amount, index: this.slpChangeAmt.index };\n  }\n\n  public get BchChangeOutput(): { amount: number, index: number } | null {\n    if (!this.txn._changeIndex) {\n      return null;\n    }\n    let idx = this.txn._changeIndex;\n    return { amount: this.txn.outputs[idx].satoshis, index: idx };  \n  }\n\n  public get Inputs(): Array<Transaction.Input> {\n    return [...this.txn.inputs];\n  }\n\n  public get Outputs(): Array<[Transaction.Output, Big?]> {\n    return this.txn.outputs.map((o, i) => {\n      let slpAmt = Big(0);\n      if (i > 0 && i-1 < this.slpOutputs.length) {\n        slpAmt.add(this.slpOutputs[i-1]);\n      } else if (this.slpChangeAmt && i === this.slpOutputs.length+1) {\n        slpAmt.add(this.slpChangeAmt.amount);\n        if (this.slpChangeAmt.index !== i) {\n          throw Error(\"slp change has wrong index\");\n        }\n      }\n      return [o, slpAmt];\n    });\n  }\n\n  constructor(wallet: Wallet) {\n    this.wallet = wallet;\n  }\n\n  public AddSlpOutput(address: string, amount: Big, tokenId: string): void {\n    if (this.tokenId !== tokenId) {\n      this.slpOutputs = [];\n      this.tokenId = tokenId;\n    }\n    if (tokenId === \"bch\") {\n      throw Error(\"can't add slp token with bch token id\")\n    }\n\n    // remove bch change\n    this.txn._changeScript = undefined;\n    if (this.txn._changeIndex !== undefined) {\n      this.txn.removeOutput(this.txn._changeIndex);\n      this.txn._changeIndex = undefined;\n    }\n\n    if (this.slpChangeAmt) {\n      this.txn.removeOutput(this.slpChangeAmt!.index);\n      this.slpChangeAmt = undefined;\n    }\n\n    const index = this.slpOutputs.length + 1;\n    this.txn.addOutput(new Transaction.Output({\n      script: new Script(new Address(address)),\n      satoshis: DUST_LIMIT\n    }), index);\n    this.slpOutputs.push(amount);\n\n    this.addSlpInputs(tokenId);\n    this.addBchInputs();\n  }\n\n  public AddBchOutput(address: Address, amount: number): boolean {\n    this.txn.to(address, amount);\n    let bool = this.addBchInputs();\n    return bool;\n  }\n\n  public async SignTransaction(getKeys: () => PrivateKeys|Promise<PrivateKeys>): Promise<SignedTxInfo> {\n    let pk = await getKeys();\n    this.txn.sign(pk);\n    const txnHex = this.txn.serialize();\n    let fee = this.txn.inputAmount - this.txn.outputAmount;\n    return { txnHex, fee, sendAmount: this.txn.outputAmount };\n  }\n\n  // addBchInputs selects coins from smallest value to largest adding them to\n  // the transaction and checking for sufficient fee. \n  // If sufficient inputs are available true is returned, otherwise false is returned.\n  //\n  // TODO: respect data banks (coin banks provide better privacy, security, and smart contract interoperability)\n  // TODO: abstract this as a coin chooser object added to the wallet\n  private addBchInputs(): boolean { // coins: Map<outpoint, { amount: Big, address: Address}>): boolean {\n    this.txn.change(this.wallet.Address.toCashAddress());\n\n    const checkInputs = () => {\n      this.txn.feePerByte(FEE_RATE);\n      let feeRate = Wallet.GetFeeRate(this.txn);\n\n      // let changeAmt = 0;\n      // if (this.txn.getChangeOutput()) {\n      //   changeAmt = this.txn.getChangeOutput()!.satoshis;\n      // }\n      // console.log(`input amt: ${this.txn.inputAmount}`);\n      // console.log(`output amt: ${this.txn.outputAmount}`);\n      // console.log(`change amt: ${changeAmt}`);\n      // console.log(`fee rate: ${feeRate}`);\n\n      if (this.txn.inputAmount >= this.txn.outputAmount && feeRate >= FEE_RATE) {\n        return true;\n      }\n      return false;\n    };\n\n    let bchCoins = Array.from(this.wallet.BchCoins).sort((a, b) => a[1].satoshis.sub(b[1].satoshis).toNumber());\n\n    for (const coin of bchCoins) {\n\n      // don't add same coin twice\n      let skipCoin = false;\n      const txid = coin[0].slice(0, 64);\n      const vout = Buffer.from(coin[0].slice(64), \"hex\").readUInt32BE(0);\n      for (const input of this.txn.inputs) {\n        if (txid === input.prevTxId.toString(\"hex\") && vout === input.outputIndex) {\n          skipCoin = true;\n          break;\n        }\n      }\n      if (skipCoin) {\n        continue;\n      }\n\n      // check if current input amount is sufficient\n      if (this.txn.outputs.length > 0) {\n        if (checkInputs()) {\n          return true;\n        }\n      }\n\n      // add the input\n      this.txn.addInput(new Transaction.Input.PublicKeyHash({\n        output: new Transaction.Output({\n          script: Script.buildPublicKeyHashOut(coin[1].address),\n          satoshis: coin[1].satoshis.toNumber()\n        }),\n        prevTxId: Buffer.from(txid, \"hex\"),\n        outputIndex: vout,\n        script: Script.empty()\n      }));\n      this.txn.feePerByte(FEE_RATE);\n    }\n\n    return checkInputs();\n  }\n\n  private createMd(tokenId: string, amounts: Big[]) {\n    let amts = amounts.map(n => new mdm.BN(n.toFixed()));\n    let tm = this.wallet.TokenMetadata.get(tokenId)!;\n    switch (tm.getTokenType()) {\n      case SlpVersionType.TokenVersionType1:\n        return mdm.TokenType1.send(tokenId, amts);\n      case SlpVersionType.TokenVersionType1_NFT_Group:\n        return mdm.NFT1.Group.send(tokenId, amts);\n      case SlpVersionType.TokenVersionType1_NFT_Child:\n        return mdm.NFT1.Child.send(tokenId, [new mdm.BN(1)]);\n    }\n  };\n\n  // addSlpInputs selects slp coins and updates variables slpOutputs and slpChange as required.\n  // \n  private addSlpInputs(tokenId: TokenId) {\n\n    // get coins we can access for this slp token\n    let slpCoins = Array.from(this.wallet.SlpCoins.get(tokenId)!).sort((a, b) => a[1].amount.sub(b[1].amount).toNumber());\n\n    // method to check inputs >= outputs\n    const checkSlpInputs = (): boolean => {\n\n      if (this.slpChangeAmt) {\n        this.txn.removeOutput(this.slpChangeAmt!.index);\n        this.slpChangeAmt = undefined;\n      }\n\n      const slpInputAmt = this.txn.inputs.reduce((p, _, i) => {\n        const slpCoins = this.wallet.SlpCoins.get(tokenId)!;\n        if (!slpCoins) {\n          return Big(0);\n        }\n        const outpoint = Utils.outpointToKey(this.txn.inputs[i].prevTxId, this.txn.inputs[i].outputIndex, true);\n        if (slpCoins.has(outpoint)) {\n          return p.add(slpCoins.get(outpoint)!.amount);\n        }\n        return p;\n      }, Big(0));\n\n      const slpOutputAmt = this.slpOutputs.reduce((p, c, i) => p.add(c), Big(0));\n\n      // console.log(`slp input amt: ${slpInputAmt}`);\n      // console.log(`slp output amt: ${slpOutputAmt}`);\n\n      if (slpInputAmt.gt(slpOutputAmt)) {\n        // set slp change output here\n        this.slpChangeAmt = { amount: slpInputAmt.minus(slpOutputAmt), index: this.slpOutputs.length + 1 };\n        //console.log(`slp change amt: ${this.slpChangeAmt.amount}`);\n\n        // set the slp change dust output\n        this.txn.addOutput(new Transaction.Output({\n          //@ts-ignore\n          script: new Script(this.wallet.Address!),\n          satoshis: DUST_LIMIT\n        }), this.slpChangeAmt!.index);\n      }\n\n      if (slpInputAmt.gte(slpOutputAmt)) {\n        // set the slp metadata message\n        if (this.slpOpreturnMessage) {\n          this.txn.removeOutput(0);\n        }\n        const outputs = this.SlpChangeOutput ? [ ...this.slpOutputs, this.slpChangeAmt!.amount ] : this.slpOutputs;\n        this.slpOpreturnMessage = this.createMd(tokenId, outputs);\n        this.txn.addOutput(new Transaction.Output({\n          script: this.slpOpreturnMessage,\n          satoshis: 0\n        }), 0);\n      \n        return true;\n      }\n\n      return false;\n    };\n\n    // loop through available slp coins to check if inputs are needed\n    for (const coin of slpCoins) {\n\n      // don't add same coin twice\n      let skipCoin = false;\n      const txid = coin[0].slice(0, 64);\n      const vout = Buffer.from(coin[0].slice(64), \"hex\").readUInt32BE(0);\n      for (const input of this.txn.inputs) {\n        if (txid === input.prevTxId.toString(\"hex\") && vout === input.outputIndex) {\n          skipCoin = true;\n          break;\n        }\n      }\n      if (skipCoin) {\n        continue;\n      }\n\n      // check if current input amount is sufficient\n      if (this.slpOutputs.length > 0) {\n        if (checkSlpInputs()) {\n          return true;\n        }\n      }\n\n      // add the slp input\n      this.wallet.SlpOutpointCache.set(coin[0], { amount: coin[1].amount, satoshis: coin[1].satoshis, address: coin[1].address, tokenId });\n      this.txn.addInput(new Transaction.Input.PublicKeyHash({\n        output: new Transaction.Output({\n          script: Script.buildPublicKeyHashOut(coin[1].address),\n          satoshis: coin[1].satoshis.toNumber()\n        }),\n        prevTxId: Buffer.from(txid, \"hex\"),\n        outputIndex: vout,\n        script: Script.empty()\n      }));\n    }\n\n    return checkSlpInputs();\n  }\n\n}\n\nexport type PrivateKeys = Array<PrivateKey | string> | PrivateKey | string\nexport type SignedTxInfo = { txnHex: string, fee: number, sendAmount: number }\n","import { Big } from \"big.js\";\nimport * as bip32 from \"bip32\";\nimport * as bip39 from \"bip39\";\nimport { Address, PrivateKey, Transaction as Txn } from \"bitcore-lib-cash\";\nimport { TokenMetadata, Transaction } from \"grpc-bchrpc-web\";\n\nimport { App, Outpoint, TokenId, WalletStorage } from \"./Interfaces\";\nimport { CacheSet } from \"../CacheSet\";\nimport { BchdNetwork } from \"./Network/BchdNetwork\";\nimport Utils from \"./Utils\";\n\nconst txidsSeen = new CacheSet<string>(100000);\nconst addressPath = \"m/44'/245'/0'/0/0\";\n\nexport class Wallet {\n\n  public SlpOutpointCache = new Map<Outpoint, { amount: Big, address: Address, satoshis: Big, tokenId: string}>();\n\n  public static EstimateTxnSize(txn: Txn) {\n    return txn._estimateSize();\n  }\n\n  public static GetFeeRate(txn: Txn) {\n    let size = Wallet.EstimateTxnSize(txn);\n    console.log(`estimated size: ${size}`);\n\n    const fee = txn.inputAmount - txn.outputAmount;\n    if (!fee || fee < 0) {\n      return 0;\n    }\n    let rate = fee / size;\n    console.log(`estimated fee rate: ${rate}`);\n    return rate;\n  }\n\n  private storage: WalletStorage;\n  private network: BchdNetwork;\n  private parent?: App;\n  private mnemonic?: string;\n  private privateKey: PrivateKey;\n\n  // // this will be used by the application api to access coins\n  // private banks = new Map<bank, { addresses: Set<address>, domain: string }>();\n  // private addresses = new Map<address, { bank: string, kind: AddressKind, info: number|Buffer }>();\n  // private transactions = new Map<txid, { height: number }>();\n\n  private bchTxi = new Map<Outpoint, { satoshis: Big, address: Address}>();\n  private bchTxo = new Map<Outpoint, { satoshis: Big, address: Address}>();\n  private slpTxi = new Map<TokenId, Map<Outpoint, { amount: Big, address: Address, satoshis: Big }>>();\n  private slpTxo = new Map<TokenId, Map<Outpoint, { amount: Big, address: Address, satoshis: Big }>>();\n\n  // private bch = new Map<bank, { bchTxi: Map<address, Map<outpoint, Big>>, bchTxo: Map<address, Map<outpoint, Big>> }>();\n  // private slp = new Map<bank, Map<tokenId, { slpTxi: Map<address, Map<outpoint, Big>>, slpTxo: Map<address, Map<outpoint, Big>> }>>();\n\n  private tokenMetadata = new Map<TokenId, TokenMetadata>();\n\n  constructor(storage: WalletStorage, network: BchdNetwork, parent?: App) { // bankPermissions: bank[]) {\n    this.storage = storage;\n    this.network = network;\n    this.parent = parent;\n    \n    // check for wif first\n    if (this.storage.GetWif()) {\n      this.privateKey = new PrivateKey(this.storage.GetWif()!);\n    } else {\n      this.mnemonic = bip39.generateMnemonic();\n      let seed = bip32.fromSeed(bip39.mnemonicToSeedSync(this.mnemonic));\n      let child = seed.derivePath(addressPath);\n      this.privateKey = new PrivateKey(child.toWIF());\n      if (this.storage.GetSeed() === null) {\n        this.storage.SetSeed(this.mnemonic);\n      } else {\n        this.mnemonic = this.storage.GetSeed()!;\n        seed = bip32.fromSeed(bip39.mnemonicToSeedSync(this.mnemonic));\n        child = seed.derivePath(addressPath);\n        this.privateKey = new PrivateKey(child.toWIF());\n      }\n    }\n  }\n\n  public get Mnemonic() {\n    return this.mnemonic;\n  }\n\n  public get Wif() {\n    if (this.mnemonic) {\n      return null;\n    }\n    return this.privateKey.toWIF();\n  }\n\n  public get XPub() {\n    if (!this.Mnemonic) {\n      return null;\n    }\n    let seed = bip32.fromSeed(bip39.mnemonicToSeedSync(this.Mnemonic)).neutered();\n    return seed.toBase58();\n  }\n\n  public get PrivateKey() {\n    return this.privateKey.toWIF();\n  }\n\n  public set PrivateKey(_bip39_or_wif: string) {\n    if (! bip39.validateMnemonic(_bip39_or_wif)) {\n      try {\n        this.privateKey = new PrivateKey(_bip39_or_wif);\n      } catch (_) {\n        throw Error(\"invalid mnemonic and invalid wif\");\n      }\n    } else {\n      const seed = bip32.fromSeed(bip39.mnemonicToSeedSync(this.mnemonic!));\n      const child = seed.derivePath(addressPath);\n      this.privateKey = new PrivateKey(child.toWIF());\n    }\n\n    this.LoadInitialBalances();\n  }\n\n  public get Address() { return this.privateKey.toAddress(); }\n\n  public get BchCoins() {\n    let coins = new Map<Outpoint, { satoshis: Big, address: Address }>();\n    this.bchTxo.forEach((dat, outpoint) => {\n      coins.set(outpoint, dat);\n      if (this.bchTxi.has(outpoint)) {\n        coins.delete(outpoint);\n      }\n    });\n    return coins;\n  }\n\n  public get SlpCoins() {\n    let coins = new Map<TokenId, Map<Outpoint, { amount: Big, address: Address, satoshis: Big }>>();\n    this.slpTxo.forEach((_coins, tokenId) => {\n      let coinMap: Map<Outpoint, { amount: Big, address: Address, satoshis: Big }>;\n      if (!coins.has(tokenId)) {\n        let coinMap = new Map<Outpoint, { amount: Big, address: Address, satoshis: Big }>();\n        coins.set(tokenId, coinMap);\n      }\n      coinMap = coins.get(tokenId)!;\n      let inputs = this.slpTxi.get(tokenId);\n      _coins.forEach((dat, outpoint) => {\n        coinMap.set(outpoint, dat);\n        if (!this.SlpOutpointCache.has(outpoint)) {\n          this.SlpOutpointCache.set(outpoint, { amount: dat.amount, satoshis: dat.satoshis, address: dat.address, tokenId });\n        }\n        if (inputs && inputs!.has(outpoint)) {\n          coinMap.delete(outpoint);\n        }\n      });\n\n    });\n    return coins;\n  }\n\n  public get TokenMetadata() { return this.tokenMetadata; }\n\n  public isMine(address: string) {\n    if (address === this.Address.toCashAddress()) {\n      return true;\n    }\n    return false;\n  }\n\n  // GetChangeOutput returns an array of transaction outputs that\n  // will be sent to this wallet.  Note that txn.getChangeOutput() has\n  // been found to be unreliable perhaps due to the way outputs are added\n  // to transactions by this wallet class.\n  public GetChangeOutput(txn: Txn): Array<Txn.Output> {\n    let change: Array<Txn.Output> = [];\n    txn.outputs.forEach(output => { \n      if (this.isMine(output.script.toAddress().toCashAddress())) {\n        change.push(output);\n      }\n    });\n\n    return change;\n  }\n\n  public async LoadInitialBalances() {\n    this.bchTxi = new Map<Outpoint, { satoshis: Big, address: Address}>();\n    this.bchTxo = new Map<Outpoint, { satoshis: Big, address: Address}>();\n    this.slpTxi = new Map<TokenId, Map<Outpoint, { amount: Big, address: Address, satoshis: Big }>>();\n    this.slpTxo = new Map<TokenId, Map<Outpoint, { amount: Big, address: Address, satoshis: Big }>>();\n  \n    const res = await this.network.GetAddressTransactions(this.Address.toCashAddress());\n    await this.indexTransactionIO(res.getConfirmedTransactionsList());\n    await this.indexTransactionIO(res.getUnconfirmedTransactionsList()!.map(o => o.getTransaction()!));\n    this.updateParent();\n  }\n\n  public UpdateMnemonic(m: string) {\n    if (! bip39.validateMnemonic(m)) {\n      try {\n        // @ts-ignore\n        PrivateKey._transformWIF(m);\n        this.privateKey = PrivateKey.fromWIF(m);\n        this.mnemonic = undefined;\n        this.storage.SetWif(m);\n      } catch (_) {\n        throw Error(\"invalid mnemonic and invalid wif\");\n      }\n    } else {\n      this.mnemonic = m;\n      this.storage.SetSeed(this.mnemonic);\n      localStorage.setItem(\"bitcore-fun-seed\", this.mnemonic);\n      const seed = bip32.fromSeed(bip39.mnemonicToSeedSync(this.mnemonic));\n      const child = seed.derivePath(addressPath);\n      this.privateKey = new PrivateKey(child.toWIF());\n    }\n\n    this.LoadInitialBalances();\n  }\n\n  public GetBchBalance(): Big {\n    const inputAmt = Array.from(this.bchTxi!).reduce((p, c) => p.add(c[1].satoshis), Big(0));\n    return Array.from(this.bchTxo!).reduce((p, c) => p.add(c[1].satoshis), Big(0)).sub(inputAmt);\n  }\n\n  public GetSlpBalances(): Map<TokenId, Big> {\n    const slpBals = new Map<TokenId, Big>();\n    Array.from(this.slpTxi!).forEach((coins) => {\n      slpBals.set(coins[0], Array.from(coins[1]).reduce((p, c) => p.add(c[1].amount), Big(0)));\n    });\n    Array.from(this.slpTxo!).forEach((coins) => {\n      let bal = slpBals.get(coins[0])!;\n      if (!bal) { bal = Big(0); }\n      let outs = Array.from(coins[1]).reduce((p, c) => p.add(c[1].amount), Big(0));\n      slpBals.set(coins[0], outs.sub(bal));\n    });\n    return slpBals;\n  }\n\n  private updateParent = () => {\n    if (this.parent) {\n      this.parent.UpdateWalletUI();\n    }\n  }\n\n  public Subscribe() {\n    const cb = (txn: Transaction) => {\n      this.processNewTransaction(txn);\n    };\n    this.network.Subscribe([this.Address.toCashAddress()], cb);\n  }\n\n  private async processNewTransaction(txn: Transaction) {\n    const txid = Utils.hashToTxid(txn.getHash_asU8());\n    if (txidsSeen.has(txid)) {\n      return;\n    }\n    txidsSeen.push(txid);\n    console.log(`${txid}`);\n    await this.indexTransactionIO([txn]);\n    this.updateParent();\n  };\n\n  public async SendTransaction(txnHex: string) {\n    const txid = await this.network.SendTransaction(txnHex);\n    const txn = await this.network.GetTransaction(txid);\n    this.processNewTransaction(txn.getTransaction()!);\n    return txid;\n  }\n\n  private async indexTransactionIO(txns: Transaction[]) {\n    let tokenIds = new Set<string>();\n\n    for (const tx of txns) {\n      for (const inp of tx.getInputsList()) {\n        if (!this.Address.toCashAddress().includes(inp.getAddress())) {\n          continue;\n        }\n        const op = Utils.outpointToKey(inp.getOutpoint()!.getHash_asU8(), inp.getOutpoint()!.getIndex());\n        if (inp.hasSlpToken()) {\n          const _tokenId = Buffer.from(inp.getSlpToken()!.getTokenId_asU8()).toString(\"hex\");\n          tokenIds.add(_tokenId);\n          if (!this.slpTxi.has(_tokenId)) {\n            this.slpTxi.set(_tokenId, new Map<Outpoint, { amount: Big, address: Address, satoshis: Big }>());\n          }\n          this.slpTxi.get(_tokenId)!.set(op, { amount: Big(inp.getSlpToken()!.getAmount()), address: new Address(inp.getAddress()), satoshis: Big(inp.getValue()) });\n        } else {\n          this.bchTxi.set(op, { satoshis: Big(inp.getValue()), address: new Address(inp.getAddress()) });\n        }\n      }\n      for (const out of tx.getOutputsList()) {\n        if (!out.getAddress() || !this.Address.toCashAddress().includes(out.getAddress())) {\n          continue;\n        }\n        const op = Utils.outpointToKey(tx.getHash_asU8(), out.getIndex());\n        if (out.hasSlpToken()) {\n          const _tokenId = Buffer.from(out.getSlpToken()!.getTokenId_asU8()).toString(\"hex\");\n          tokenIds.add(_tokenId);\n          if (!this.slpTxo.has(_tokenId)) {\n            this.slpTxo.set(_tokenId, new Map<Outpoint, { amount: Big, address: Address, satoshis: Big }>());\n          }\n          this.slpTxo.get(_tokenId)!.set(op, { amount: Big(out.getSlpToken()!.getAmount()), address: new Address(out.getAddress()), satoshis: Big(out.getValue()) });\n        } else {\n          this.bchTxo.set(op, { satoshis: Big(out.getValue()), address: new Address(out.getAddress()) });\n        }\n      }\n    }\n\n    const tmRes = await this.network.GetTokenMetadata([...tokenIds.keys()]);\n    tmRes.getTokenMetadataList().forEach(tm => this.tokenMetadata.set(Buffer.from(tm.getTokenId_asU8()).toString(\"hex\"), tm));\n  }\n}\n"],"sourceRoot":""}